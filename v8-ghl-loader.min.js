//https://cdn.jsdelivr.net/gh/core-gs/masterstyle-gs@latest/v8-ghl-loader.min.js
//https://cdn.jsdelivr.net/gh/ghlstyle/d-theme@latest/user-d-custom-theme.css



// GHL Loader (SPA route-aware, strict+fallback, robust DOM watch & swap)
// - Detects SPA route changes (/v2/location/:id) without reload and swaps styles
// - Scopes stable theme (__USER__ -> .loc-<id>) and promotes matching manual CSS
// - Adds/removes loc-<id> on <html> and on raw-id containers
// - Exact id first; else blank if present; otherwise no-op

(function () {
  if (window.__GHL_LOADER__) return;
  window.__GHL_LOADER__ = true;

  var DEFAULT_TEMPLATE_URL = "https://cdn.jsdelivr.net/gh/ghlstyle/d-theme@latest/user-d-custom-theme.css";

  // Internal state
  var STATE = {
    currentKey: null, // 'blank' or locationId
    lastHref: location.href,
    ensureWatchers: {}, // id -> MutationObserver started
  };

  function currentScript() {
    return document.currentScript || (function () {
      var s = document.getElementsByTagName("script");
      return s[s.length - 1] || null;
    })();
  }

  function getRouteId() {
    var m = location.href.match(/\/v2\/location\/([^\/\?#]+)/);
    return m ? m[1] : null;
  }

  function scopeClass(id) { return "loc-" + id; }

  // ----- Class attach/remove -----
  function attachScopeClasses(id) {
    if (!id || id === "blank") return;
    var cls = scopeClass(id);
    document.documentElement.classList.add(cls);
    try {
      var nodes = document.getElementsByClassName(id);
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.classList && !node.classList.contains(cls)) node.classList.add(cls);
      }
    } catch (_) {}
  }

  function detachScopeClasses(id) {
    if (!id || id === "blank") return;
    var cls = scopeClass(id);
    document.documentElement.classList.remove(cls);
    try {
      var nodes = document.getElementsByClassName(cls);
      // getElementsByClassName live list; convert to array copy
      var arr = [];
      for (var i = 0; i < nodes.length; i++) arr.push(nodes[i]);
      for (var j = 0; j < arr.length; j++) {
        var el = arr[j];
        if (el.classList) el.classList.remove(cls);
      }
    } catch (_) {}
  }

  function watchAndEnsureScope(id) {
    if (!id || id === "blank") return;
    if (STATE.ensureWatchers[id]) return;
    var cls = scopeClass(id);
    var start = Date.now();

    // ensure once immediately
    attachScopeClasses(id);

    var mo = new MutationObserver(function (muts) {
      for (var k = 0; k < muts.length; k++) {
        var m = muts[k];

        if (m.type === "childList") {
          for (var j = 0; j < m.addedNodes.length; j++) {
            var n = m.addedNodes[j];
            if (n && n.nodeType === 1) {
              if (n.classList && n.classList.contains(id) && !n.classList.contains(cls)) {
                n.classList.add(cls);
              }
              if (n.getElementsByClassName) {
                var list = n.getElementsByClassName(id);
                for (var x = 0; x < list.length; x++) {
                  var el = list[x];
                  if (el.classList && !el.classList.contains(cls)) el.classList.add(cls);
                }
              }
            }
          }
        }

        if (m.type === "attributes" && m.attributeName === "class") {
          var el2 = m.target;
          if (el2 && el2.classList && el2.classList.contains(id) && !el2.classList.contains(cls)) {
            el2.classList.add(cls);
          }
        }
      }
      if (Date.now() - start > 15000) {
        try { mo.disconnect(); } catch (_) {}
        delete STATE.ensureWatchers[id];
      }
    });

    try {
      mo.observe(document.documentElement, {
        subtree: true,
        childList: true,
        attributes: true,
        attributeFilter: ["class"]
      });
      STATE.ensureWatchers[id] = mo;
    } catch (_) {}
  }

  // ----- Stylesheet promotion / cleanup -----
  function promotePreload(entry, key) {
    if (!entry) return null;
    var href = entry.getAttribute("href");
    if (!href) return null;
    // If already promoted for this key, skip
    var existing = document.querySelector('link[rel="stylesheet"][data-ghl-style-for="'+ key +'"]');
    if (existing && existing.getAttribute('href') === href) return existing;

    // Remove any previous promoted styles for other keys
    cleanupPromotedStylesExcept(key);

    // Create new stylesheet
    var l = document.createElement("link");
    l.rel = "stylesheet";
    l.href = href;
    l.setAttribute("data-ghl-style-for", key);
    document.head.appendChild(l);
    entry.setAttribute("data-activated", "true");
    return l;
  }

  function cleanupPromotedStylesExcept(keepKey) {
    var promoted = document.querySelectorAll('link[rel="stylesheet"][data-ghl-style-for]');
    for (var i = 0; i < promoted.length; i++) {
      var n = promoted[i];
      if (n.getAttribute("data-ghl-style-for") !== keepKey) {
        n.parentNode && n.parentNode.removeChild(n);
      }
    }
  }

  function cleanupStableThemeExcept(keepKey) {
    var links = document.querySelectorAll('link[data-user-theme-loaded]');
    for (var i = 0; i < links.length; i++) {
      var l = links[i];
      if (l.getAttribute("data-user-theme-loaded") !== keepKey) {
        l.parentNode && l.parentNode.removeChild(l);
      }
    }
  }

  // ----- Manual entries -----
  function findExactEntry(id) {
    if (!id) return null;
    return document.querySelector('link[data-ghl-id="' + id + '"]');
  }
  function findBlankEntry() {
    return document.querySelector('link[data-ghl-id="blank"]');
  }

  // ----- Stable theme fetch/scope -----
  function loadStableTheme(key, templateURL) {
    if (!key) return;
    // If already loaded for this key, skip. We'll also cleanup others in swap.
    if (document.querySelector('link[data-user-theme-loaded="' + key + '"]')) return;

    fetch(templateURL, { cache: "no-store", mode: "cors" })
      .then(function (r) {
        if (!r.ok) throw new Error("template fetch " + r.status);
        return r.text();
      })
      .then(function (css) {
        var out = (key === "blank")
          ? css.replace(/\.?__USER__\b/g, "")
          : css.replace(/\.?__USER__\b/g, "." + scopeClass(key));

        var blob = new Blob([out], { type: "text/css" });
        var href = URL.createObjectURL(blob);
        var link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = href;
        link.setAttribute("data-user-theme-loaded", key);
        document.head.appendChild(link);

        link.addEventListener("load", function () {
          setTimeout(function () {
            try { URL.revokeObjectURL(href); } catch (e) {}
          }, 1500);
        });
      })
      .catch(function (err) {
        console.warn("[GHL Loader] Stable theme template fetch failed:", err && err.message);
      });
  }

  // ----- Apply / Swap -----
  function applyWithKey(key) {
    // Require a matching manual entry
    var entry = key === "blank" ? findBlankEntry() : findExactEntry(key);
    if (!entry) return false;

    // If already applied for this key, nothing to do
    if (STATE.currentKey === key) {
      // Still ensure scope classes (in case container mounted later)
      attachScopeClasses(key);
      watchAndEnsureScope(key);
      return true;
    }

    // Swap from previous key
    var prev = STATE.currentKey;
    if (prev && prev !== key) {
      // Remove previous scope classes
      detachScopeClasses(prev);
      // Cleanup previous styles
      cleanupPromotedStylesExcept(null);  // remove all promoted styles first
      cleanupStableThemeExcept(null);     // remove all scoped stable themes
    }

    // Apply for new key
    attachScopeClasses(key);
    watchAndEnsureScope(key);

    var cs = currentScript();
    var templateURL = (cs && cs.getAttribute("data-template")) || DEFAULT_TEMPLATE_URL;

    loadStableTheme(key, templateURL);
    promotePreload(entry, key);

    STATE.currentKey = key;
    return true;
  }

  function chooseAndApplyForCurrentRoute() {
    var id = getRouteId();
    if (id) {
      if (!applyWithKey(id)) {
        // exact missing -> try blank
        applyWithKey("blank");
      }
    } else {
      // no id visible (non-location view) -> try blank
      applyWithKey("blank");
    }
  }

  // ----- SPA route change detection -----
  function installRouteWatchers() {
    // monkeypatch pushState/replaceState
    var _push = history.pushState;
    var _replace = history.replaceState;

    function handleUrlChange() {
      if (STATE.lastHref !== location.href) {
        STATE.lastHref = location.href;
        // Give SPA a tiny tick to mount DOM
        setTimeout(chooseAndApplyForCurrentRoute, 50);
      }
    }

    try {
      history.pushState = function () {
        var ret = _push.apply(this, arguments);
        handleUrlChange();
        return ret;
      };
      history.replaceState = function () {
        var ret = _replace.apply(this, arguments);
        handleUrlChange();
        return ret;
      };
    } catch (_) {}

    window.addEventListener('popstate', handleUrlChange);

    // Fallback polling (in case framework bypasses History API)
    setInterval(handleUrlChange, 300);
  }

  // ----- Boot -----
  function start() {
    installRouteWatchers();

    // Initial wait up to 10s for route id to appear, then decide/apply.
    var t0 = Date.now();
    var timer = setInterval(function () {
      var id = getRouteId();
      if (id || Date.now() - t0 > 10000) {
        clearInterval(timer);
        chooseAndApplyForCurrentRoute();
      }
    }, 120);
  }

  if (document.readyState !== "loading") start();
  else document.addEventListener("DOMContentLoaded", start);
})();
